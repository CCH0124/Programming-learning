# JAVA 執行續
## 基本概念
### 程序
- 完成特定任務。是指一段靜態代碼，靜態對象
### 行程
- 程序的一次執行過程，或是正在運行的一個程序。為動態過程：有產生、存在和死亡的過程
- 進程作為資源分配的單元，系統在運作時會為每個進程分配不同的記憶體區域
### 線程
- 是一個程序內部的一條執行路徑。
- 一個進程同一時間並行執行個執行續，就是多執行續
- 執行續做為調度和執行續單位，每個現成擁有**獨立的運行 stack** 和**程式計數器**（pc），執行續的開銷較小
- 執行續共享記憶體資源（Method Area、Heap）
### 單核 CPU 和多核 CPU
單核 CPU，是假多執行續，一個單元時間內，只能執行一個執行續的任務。當有多個任務進入該 CPU 時，會以時間單元內的方式去輪流執行
### Concurrency 和 Parallelism
- Concurrency 並行
    - 多個 CPU 同時執行多個任務
    - 多人同時間做不同事
- Parallelism 平行
    - 一個 CPU（採用時間片）同時執行多個任務
    - 多個人做同一件事 
### 何時需要多執行續
程序需同時執行兩個或多個任務等
## 線程創建和使用
1. 繼承 Thread
2. 重寫 Thread run 方法
3. 創建子類對象
4. 藉由對象調用 start 方法
    4.1 啟動當前執行續
    4.2 調用當前執行續 run 方法

不能夠讓已經 start 的執行續去執行，會報錯。需要重新創建執行續對象。

### Thread 類相關方法
- start()
    - 啟用執行續
- run()
    - 執行續被調用時執行的操作
- getName()
    - 返回值行續名稱
- setName(String name)
    - 設置該執行續名稱
- Thread currenThread()
    - 返回當前執行續
- yield()
    - 執行續讓步
    - 暫停當前正在執行的執行續，把執行機會讓給優先級相同或更高的執行續
    - 如果當前無同優先級的執行續，則省略
- join()
    - 當某個執行續流中調用其他執行續的 join() 方法時，調用執行續將被阻塞，直到 join 加入的 join 執行續執行完為止
- sleep(long millis)
    - 使當前執行的執行續在指定時間內放棄對 CPU 的控制，使其他執行續有機會被執行，時間到後重新排隊
- stop()
    - 強制執行續生命週期停止
- boolean isAlive()
    - 半段執行續使否活著

### 執行續調度
- 調度策略
    - CPU 時間片
    - 搶占式
        - 高優先級搶占 CPU
- java 調度方式
    - 同優先級執行續組成先進先出對列，使用時間切片策略
    - 對高優先級，使用優先調度的搶占式策略
### 執行續優先級
- 執行續的優先級等級
    - start 之前設置
    - MAX_PRIORITY：10
    - MIN_PRIORITY：1
    - NORM_PRIORITY：5
方法：
- getPriority
- setPriority

### 比較兩種創建方式
- Thread
    - 實現 Runable
- Runnable
    - 開發中，優先選擇
        - 實現的方式沒有類的單繼層的侷限性
        - 實現的方式更適合來處理多個執行續有共享數據的情況
- 上面兩種方式都需要覆寫 run，執行續邏輯都在 run 裡面

### 執行續分類
JAVA 中可分為兩類
- 守護執行續
    - 用來服務*用戶執行續*
- 用戶執行續

## 線程的生命週期
- 新建
- 就緒
    - 被 start() 後，等待 CPU 時間切片
- 運行
    - 獲得 CPU 資源，run() 定義執行續操作和功能
- 阻塞
    - 讓出 CPU 並臨時終止自己的執行，進入阻塞狀態
- 死亡
    - 執行續完成了全部工作或被提前強制性中止或出現異常中止

![](https://i.imgur.com/DoZNz99.png)

## 線程的同步
執行續安全問題。透過同步解決執行續安全
1. 同步程式碼塊
操作共享數據（多個執行續過同操作的變量）的代碼，即為需要被同步程式碼。moniter，任何一個類的地方都可以充當鎖或 class_file.class 他只會載入一次，**多個執行續必須共用一把鎖**。這樣方式相當於單執行續，效率變低。

在實現 Runnable 街口創建執行續方式中，我們可考慮使用 this 充當 moniter
```java=
synchronized(moniter) {
    // 須被同步程式碼
}
```
2. 同步方法
如果操作工想數據的代碼完整宣告在一個方法中，可將此方法聲明為同步，繼層方式的執行續，需使用 static 方法
```java=
public synchronized void show() { // this
    // 須被同步程式碼
}
```

### 死鎖問題
不同執行續分別占用對方需要的同步資源，帶相互等待對方放棄自己需要的資源，就形成了死鎖。該情況不會出錯和異常，所有狀態都為阻塞，無法繼續。撰寫 synchronized 時應避免死鎖。
- 減少同步資源定義
- 盡量避免嵌套同步

### Lock
解決執行續安全問題 Lock 方式

### synchronized vs Lock
- 都可解決執行續安全問題
- synchronized 自動釋放，lock 需手動啟動和結束


## 線程的通訊
- wait
    - 觸發時，當前執行續會進入阻塞狀態，並釋放同步 mointer
- notify
    - 觸發時，會喚醒被 wait 的一個執行續，如果有多個被 wait，會以優先級高的先被喚醒
- notifyAll
    -  觸發時，喚醒所有被 wait 的執行續

上述的方法，都只能在同步代碼或方法中執行；調用者必須是同步代碼或方法中的同步 mointer，否則會出現異常。
上述方法都定義在 `java.lang.Object`

- sleep 和 wait 異同 ?
    - 相同
        - 一旦觸發時，都可讓當前執行續進入阻塞狀態
    - 不同
        - 兩個宣告位置不一樣，一個是 Thread，一個是 Object
        - 調用場景不一樣，sleep 可在任何，wait 需再同步代碼或方法中
        - 是否釋放同步 mointer，當兩個都在同步下，sleep 不會釋放鎖，wait 則會
- 消費者和生產者

## JDK5 新增創建執行續方式
### callable
比 Runnable 更強大
- 相比 `run` 可返回值
- 可拋異常
- 可支持泛型
- 需借助`FutureTask` 類

- Future interface
    - 可針對具體 `Runnable`、`Callable` 任務的執行結果進行取消、查詢是否完成、獲取結果等
    - FutureTask 是 Future 的唯一實現類
    - 同時實現 `Runnable`、`Callable` 接口
創建步驟
1. 實現 Callable
2. 將動作寫入至 call 方法
3. 創建實現 Callable 的物件
4. 創建 FutureTask 物件
5. FutureTask 物件傳入至 Thread 中，調用 start
### Thread Pool 
提前建立好多個執行續，放入執行續池中，使用時直接取用，使用完放回。可避免頻繁創建銷毀，實現重複利用。

可提高回應速度，降低資源消耗，便於管理
- corePoolSize
    - 核心池的大小
- maximumPookSize
    - 最大執行續數量
- keepAliveTime
    - 執行續煤任務時最多保持多長時間後會中止
