# Java數據結構和算法
## 線性結構和非線性結構
- 線性結構
    - 數據元素之間存在一對一關係
    - 兩種不同的儲存結構
        - 順序儲存結構（Array）
            - 儲存元素為連續
        - 鏈式儲存結構（鏈表）
            - 儲存元素為非連續
- 非線性結構
    - 二維陣列
    - 廣義表
    - 樹結構
    - 圖結構

## 稀疏陣列和隊列
### 稀疏陣列
當一個陣列大部分元素為 0，或者為同一個值的陣列時，可以使用稀疏矩陣來保存該陣列。

處裡方式
1. 紀錄陣列一共幾行幾列，有多少個不同值
2. 把具有不同值的元素的行列及值記錄在一個小規模的陣列中，從而縮小程序的規模

### 隊列
- 有序列表，可用陣列或鍊表實現
- 先入先出原則
- 環形隊列
    - 充分利用陣列

## Linked List
- 鍊表示已節點的方式來儲存，是鏈式儲存
- 每個節點包含 data 和 next（指向下一個節點）
- 個個節點不一定是連續儲存

## Doubly linked list
- 單項鏈表
    - 查找方向為一個
    - 不能自我刪除，需靠輔助節點

## 單向環形鏈表
- Josephu

## stack
- FILO-first In Last out

### 逆波瀾（後綴表達式）

## 遞迴
- 自己方法調用自己
- 當程式執行到一個方法時，就會開闢一個獨立的空間(stack)
- 方法中的局部變量是獨立的，不會相互影響
- 會有停止規則，遞迴不斷向該條件前進，否則會有 `StackOverflowError`

## 時間頻率 $T(n)$
一個算法花費的時間與算法中語句執行次數成正比，哪個算法執行越多，花費時間就越多。
## 時間複雜度

## 排序
- 泡沫
- 選擇
- 插入
- 快速
- shell
- Merge
    - divide and conquer
    ![](https://miro.medium.com/max/1400/1*61Mf0zjVfd1s3_SzUNGxPA.png)
- radix
    - 穩定，多個相同的值，依舊保有原有順序
    - 對負數不適合
- heap sort
    - 完全二元樹
        - 每個節點的值都大於或等於其左有孩子節點值，稱大頂堆，通常是升序
        - 每個節點的值都小於或等於其左有孩子節點值，稱小頂堆，通常為降序
    - 實現基本流程
        - 將待排序序列構成大頂堆
        - 此時，整個序列最大值為頂堆的根節點
        - 將其與末尾元素進行交換，此時末尾為最大值
        - 然後將剩餘 n-1 元素重新構成一個堆，這樣會取得 n 個元素的次小值，反覆執行便可形成有序序列


### 時間複雜度
|排序演算法|平均時間複雜度|最好|最壞|空間複雜度|排序方式|穩定性|
|---|---|---|---|---|---|---|
|Bubble Sort|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|in-place|穩定|
|Selection Sort|$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$|in-place|不穩定|
|Insert Sort|$O(n^2)$|$O(n)$|$O(n^2)$|$O(1)$|in-place|穩定|
|Shell Sort|$O(n log n)$|$O(n log^2 n)$|$O(n log^2 n)$|$O(1)$|in-place|不穩定|
|Merge Sort|$O(n log n)$|$O(n log n)$|$O(n log^2 n)$|$O(n)$|out-place|穩定|
|Quick Sort|$O(n log n)$|$O(n log n)$|$O(n^2)$|$O(log n)$|in-place|不穩定|
|heap Sort|$O(n log n)$|$O(n log n)$|$O(n log n)$|$O(1)$|in-place|不穩定|
|Counting Sort|$O(n+k)$|$O(n+k)$|$O(n+k)$|$O(k)$|out-place|穩定|
|Bucket Sort|$O(n+k)$|$O(n+k)$|$O(n^2)$|$O(n+k)$|out-place|穩定|
|Radix Sort|$O(n*k)$|$O(n*k)$|$O(n*k)$|$O(n+k)$|out-place|穩定|

- in-place
    - 不用額外記憶體
- out-place
    - 需額外記憶體

## 搜尋演算法
### 順序
- 可有序或無序
### 二分
- 需有序陣列
### 插值
- 需有序陣列
- 類似二分，插值是自適應 mid 開始查找
- 對數據量大，分布較均勻的話，用此方法會較有優勢，否則效能不一定優
原先二分是 $mid = \frac{low+hight}{2}$
自適應方式是 $mid = low + \frac{key-a[low]}{a[high]-a[low]}(high-low)$
### 斐波那契
- 也是會求 mid，但是用 $mid = low+F(k-1)-1$ 取得，$F$　表示斐波那契
- 其中數據長度 n 不一定剛好等於 $F[k]-1$，需要對數據多增加至$F[k]-1$

## 哈希表 
## 樹 
- 陣列
    - 使用 index 獲取值，對有序陣列，可配合二分查找，提高檢索速度
    - 要檢索具體某個值或插入值會移動整體，效率低
    - 無法自然的動態擴展
- 鏈結方式
    - 插入數值，只需插入節點，刪除效率也高
    - 檢索時效率較低，都須從節點的頭開始
- 樹儲存
    - 儲存、讀取效率都高，可保證數據檢索速度，同時也保證插入、刪除、修改速度

![](https://i.imgur.com/u2OC9of.png)

- 節點
    - 每個物件
- 根節點
    - A
- 父節點
    - A 是 B、C、D 父
- 子節點
    - B、C、D 是 A 的子節點
- 葉子節點
    - 無子節點的節點
- 節點權
- 路徑
- 層
    - 4 層
- 子樹
    - G H I J 是 A 的子樹
- 樹的高度
- 森林
    - 多個子樹

[ref](http://www.csie.ntnu.edu.tw/~u91029/BinaryTree.html)

### 二元樹
- 一個節點最多只有 2 個子節點
- 子節點都在最後一層
    - 總結點數 $2^n-1$，$n$ 是層數
    - 滿足此條件稱*滿二元樹*
- 子節點都在最後一層或到數第二層，且前者都在左邊，後者都在右邊
    - 稱作**完全二元樹**

#### 遍歷方式
- 前序
    - 輸出父節點，在左子樹和右子樹
- 中序
    - 先左子樹，在父節點，在右子樹
- 後序
    - 先左子樹，在右子樹，最後父節點

- 看父節點輸出順序即可辨別遍歷方式

#### 刪除節點
- 刪除葉子節點，則該刪除節點
- 如果是非葉子節點，則刪除該子樹
- 應當找根結點，去判別刪除節點

### 順序二元樹
- 可和陣列相互轉換，在遍歷時依舊可以按照，前中後續遍歷

#### 特點
- 第 n 個元素的左子節點為 $2*n+1$
- 第 n 個元素的右子節點為 $2*n+2$
- 第 n 個元素的父節點為 $(n-1)/2$

:::info
n 表示二元樹中的第幾個元素，因為要對應陣列
:::

上述是二元樹，對應到陣列的 index


### Threaded binary tree
- n 個節點的二元鏈表中含有 $2n–(n-1)= n+1$ 個空指針
    - 將原本接地的指標作為引線，將左引線指向此節點的中序立即前行者 ，將右引線指向此節點的中序立即後繼者，稱為引線二元樹
        - 該附加的資訊稱為*線索*
- 根據線索性質不同，可分
    - 前序線索二元樹
    - 中序線索二元樹
    - 後序線索二元樹


### 霍夫曼樹 Huffman Tree
給定 n 個權重作為 n 個子節點，構造一棵二元樹，若該樹的權重路徑長度達到最小，該二元樹為最優二元樹，或稱霍夫曼樹。因為是帶有權重，權重越高越靠近根節點。

##### 路徑與路徑長度
在一棵樹中，從一個節點往下可以到達的孩子或孫子節點之間的通路稱為*路徑*。通路中分支的數目稱為*路徑長度*。若依照根節點的層數為 `1`，則從根節點倒第 `L` 節點的路徑長度為 `L-1`

##### 節點的權和帶權路徑長度
若樹中的節點帶有值，則稱該值為該節點的*權*，節點的帶權路徑長度為，從根節點到該節點之間的*路徑長度*與*權*的乘積

##### 樹的帶權路徑長度
所有葉子節點的帶權路徑之和，為 `WPL(Weighted Path Length)`，權值最大的節點黎根節點越近的二叉樹才是最優二叉樹。WPL 最小的就是霍夫曼樹。

[example](https://drive.google.com/file/d/1pI_A4cRp9JH2bv7Z7JaRBnq_jo7nl1Uw/view?usp=sharing)，該範例中 WPL 為 `13*2+7*2+8*2+4*2=64`
[example2](https://www.draw.io/?lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&page-id=Oej9iLlVfkVc-WAg_g00&title=dataStruct#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1pI_A4cRp9JH2bv7Z7JaRBnq_jo7nl1Uw%26export%3Ddownload)，此範例的 WPL 為 `7*1+4*2+8*3+13*3=78`

##### 霍夫曼樹建構流程
[霍夫曼樹建構流程](https://www.draw.io/?lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&page-id=XDTZg0eXB06mQ_ITbf5U&title=dataStruct#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1pI_A4cRp9JH2bv7Z7JaRBnq_jo7nl1Uw%26export%3Ddownload)
### 霍夫曼編碼
- 廣泛用於數據檔案壓縮
- 是可變長編碼（VLC）的一種

1. 取得輸入字串
2. 統計字串符中各字符對應個數
3. 按照上一步的結果構建霍夫曼樹，其個數為權值

>霍夫曼樹會因為排序方法不同，也可能會不大一樣，其對霍夫曼編碼也會不同，但 wpl 是相同的

- 如過檔案本身就是經過壓縮處理，再使用霍夫曼編碼壓縮效果不會很大
- 霍夫曼是用 byte 處理，因此幾乎可以處裡所有檔案
- 檔案內容，重複數據不多，壓縮過程不會有很大的效果

### 二叉排序樹(Binary Search Tree)
對於二叉排序樹的任何一個非葉子節點，要求左子節點的值比當前節點的值小，右子節點的值比當前節點值大。有存在相同值則左右子節點都可行。

##### 刪除
考慮情況有以下
- 刪除葉子節點
    - 取父節點處理
- 刪除只有一顆子樹的節點
- 刪除有兩顆子樹的節點

### 平衡二叉樹(self-balancing binary search tree)
- 又稱 AVL 樹 
- 當使用 BST 時，樹的路徑越深查詢效率不好，對於連續數值形成的 BST 樹
    - 使用平衡二叉樹可解決此問題
- 保證查詢效率
- 它是一顆空樹或它的左有兩子樹的高度差的絕對值不超過 1，並且左右兩子樹都是一棵平衡二叉樹
- AVL 實現方式
    - 紅黑樹
    - AVL
    - Treap
    - 伸展樹
    - ..

### 多路叉樹
- 二叉樹存在問題
    - 建構時需要 i/o 操作(大量數據存在資料庫或檔案)，當節點多時，建構二叉樹會有影響
    - 節點多造成二叉樹高度變高，會降低操作速度
- 多叉樹
    - 允許每個節點可以有更多的樹據項害更多的子節點，就是**多叉樹(multiway tree)**

##### 2-3 樹
- 所有葉子節點都在同一層
    - 只要是 B 樹都滿足此條件
- 有兩個子節點的節點叫二節點
    - 二節點要嘛無子節點，要嘛有兩個
- 有三個子節點的節點叫三節點
    - 要嘛無子節點，要嘛有兩個
- 2-3 樹由二節點和三節點構成的樹

##### B樹、B+樹和B*樹
- B 即 blaced
- 2-3 樹和 2-3-4樹就是 B 樹


## 圖(Graph)
- 對於鏈表限於一個前驅和後驅節點
- 樹也只能有一個直接前驅有就是父節點
- 當需要表示多對多的關聯時，就用到了圖

##### 概念
1. 頂點(vertex)
2. 邊(edge)
3. 路徑
4. 無向圖，如下圖
5. 路徑

>無向圖指沒有方向

![](https://i.imgur.com/9kR9pAJ.png)

上面提到了有向圖，下圖為有向圖

![](https://i.imgur.com/5pgDLTk.png)

帶權圖如下

![](https://i.imgur.com/aCNXafm.png)

##### 圖表示方式
- 二維矩陣
- 鏈表示

##### 圖遍歷 
- 深度優先(Depth First Search)
- 廣度優先(Broad First Search)

## 分治演算法（Divide and Conquer）
子問題分成更小問題，最後結果在合併

## 動態規劃演算法（Dynamic Programming）
將大問題化氛圍小問題進行解決，從而一步步獲取最憂解的處理演算法。與分治演算法不同的是**適用於動態規劃求解問題，經分解得到子問題往往不是互相獨立的**，就是一個子階段的求解是建立在上一個子階段的解的基礎之上。

## KMP 演算法(Knuth-Morris-Pratt)
KMP 是一個解決模式，串是否在文本串出現過，如果出現則返回一開始出現位置

[blog](https://www.cnblogs.com/zzuuoo666/p/9028287.html)

## 貪婪演算法
- 在每一部選擇中都採取最好或者最優的選擇，從而希望能夠導致結果是最好或是最優的演算法
- 此演算法結果不一定是最優的結果

## Prim 演算法
- Minimum Cost Spanning Tree
    - 給定帶權的無向聯通圖，選取一棵樹，使樹上所有邊上權的總合最小
    - N 個頂點，一定有 N-1 條邊
## Kruskal 演算法
- 加權連通圖的最小生成樹
- 按照全值從小到大的順序選擇 $n-1$ 條邊，這些邊須保證不構成迴路

## Dijkstra
- 最短路徑演算法，計算一個節點到其它節點的最短路徑
- 是以迄點為中心向外層層擴展，直到到終點
    - 廣度優先