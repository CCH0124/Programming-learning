## JAVA 之 JMM

JAVA 規範了 JMM(Java Memory Model)，用來屏蔽調各種硬體和作業系統的記憶體訪問差異。這是為了不同平台上都能有一致的記憶體訪問效果。

JMM 本身是一種抽象概念並不真實存在它僅僅描述的是一組約定和規範，通過這組規範定義了程序中各個變量的讀寫訪問方式並決定一個執行續對共享變量的寫入何時以及如何變成對另一個線程可見，總體技術圍繞多線程的*原子性*、*可見性*和*有序性*。

### 可見性
當一個線程修改了某一個共享變量的值，其他線程是否能夠立即知道變更，JMM 規定了所有的變量都儲存在主記憶體中。

![](https://jenkov.com/images/java-concurrency/java-memory-model-6.png)

系統主要記憶體共享變量數據修改被寫入的時機是不確定的，多線程下很可能出現髒讀，所以每個線程都有自己的工作記憶體，線程自己的工作記憶體保存了該線程使用到的變量的主記憶體副本，線成對變量的所有操作都必須在自己的工作區進行，不能直接讀寫主記憶體變量。不同線程之間也無法相互讀取對方的工作區內容，因此值之間傳遞都透過主記憶體完成。


詳細內容[java-memory-model](https://jenkov.com/tutorials/java-concurrency/java-memory-model.html)
### 原子性
同一個操作是不可被打斷，在多線程環境下，操作不能被其他線程干擾。

### 有序性
對於一個線程執行程式碼而言，我們總是習慣認為程式碼執行是由上至下，有序執行。但為了提升效能，編譯器和處理器通常會對指令序列進行重新排序。JAVA 規範規定 JVM 線程內部維持順序化語意，即只要程序的最終結果與它順序執行結果相等，那麼指令的執行順序可以與程式碼順序不一致，這過程叫做指令的重排序。

指令重排可以保證串行語意一致，但沒有義務保證*多線程的語意也一致*(可能會有髒讀)，簡而言之，兩行以上不相干的程式碼再執行的時候有可能先執行的不是第一條，不見得是從上到下順序執行，執行順序會被優化。


## JMM 之 happens before 
它是判斷數據是否存在競爭，線程是否安全的非常有用手段。依賴這個原則，我們可以透過幾條簡單規則解決併發環境下兩個操作之間是否可能存在衝突的所有問題。

1. 如果第一個操作 happens-before 另一個操作，那麼第一個操作的執行結果將對第二個操作可見，而且第一個操作的執行順序排在第二個操作之前。
2. 兩個操作之間存在 happens-before 關係，並不意味著一定要按照 happens-before 原則制定的順序來執行。如果重新排序之後的結果與按照 happens-before 關係來執行結果一致，那個這種重新排序並不非法。

### 八條原則
1. 次序規則

一個線程內，按照程式碼順序寫在前面的操作先行發生於寫在後面的操作。就是前一個操作的結果可以被後續的操作獲取。
2. 鎖定規則

一個 `unlock` 操作先行發生於後面(時間上的先後)對同一個鎖的 `lock` 操作
3. volatile 變量規則

對一個 `volatile` 變量的讀寫操作先行發生於後面(時間上的先後)對這個變量的讀操作，前面的寫對後面的讀是可見的。
4. 傳遞規則

如果操作 A 先行發生於 B，而 B 又先行發生於操作 C，則可以得知操作 A 先行發生於操作 C
5. 線程啟動規則(Thread start rule)

Thread 物件的 `start()` 先行發生於此線程的每一個動作
6. 線程中斷規則(Thread interruption rule)

對線程 `interrupt()` 方法的調用先行發生於被中斷線程的程式碼檢測到中斷事件的發生。可以透過 `Thread.interrupted()` 檢測到是否發生中斷，也就是說要先調用 `interrupt()` 設置中斷的標誌，才能檢測到中斷發送
7. 線程終止規則(Thread termination rule)

線程中所有操作都先行發生於對此線程的終止檢測，可以透過 `isAlive()` 等手段檢測線程是否已經終止執行。
8. 對象終結規則(Finalizer Rule)

一個對象的初始化完成(建構函數執行結束)先行發生於它的 `finalize()` 方法的開始。物件沒有初始化完成之前，是不能調用 `finalize()` 方法



happens before 本質上是一種*可見性*。A Happens-before B 表示 A 發生過的事情對 B 來說是可見的，無論 A 事件和 B 事件是否發生在同一個線程裡。